package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/tokligence/tokligence-gateway/internal/userstore"
)

// ==============================================================================
// Query Resolvers
// ==============================================================================

// Ping is the resolver for the ping field.
func (r *queryResolver) Ping(ctx context.Context) (string, error) {
	return "pong", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*User, error) {
	// TODO: Implement authentication and get current user from context
	return nil, fmt.Errorf("not implemented: authentication required")
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*User, error) {
	uid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}
	user, err := r.Store.GetUserV2(ctx, uid)
	if err != nil {
		return nil, err
	}
	return userToGQL(user), nil
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*User, error) {
	user, err := r.Store.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, err
	}
	return userToGQL(user), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, filter *UserFilter) ([]*User, error) {
	users, err := r.Store.ListUsersV2(ctx, userFilterToStore(filter))
	if err != nil {
		return nil, err
	}
	return usersToGQL(users), nil
}

// Gateway is the resolver for the gateway field.
func (r *queryResolver) Gateway(ctx context.Context, id string) (*Gateway, error) {
	gid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	gw, err := r.Store.GetGateway(ctx, gid)
	if err != nil {
		return nil, err
	}
	return gatewayToGQL(gw), nil
}

// MyGateways is the resolver for the myGateways field.
func (r *queryResolver) MyGateways(ctx context.Context) ([]*Gateway, error) {
	// TODO: Implement authentication and get current user's gateways
	return nil, fmt.Errorf("not implemented: authentication required")
}

// OrgUnit is the resolver for the orgUnit field.
func (r *queryResolver) OrgUnit(ctx context.Context, id string) (*OrgUnit, error) {
	oid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid org unit ID: %w", err)
	}
	unit, err := r.Store.GetOrgUnit(ctx, oid)
	if err != nil {
		return nil, err
	}
	return orgUnitToGQL(unit), nil
}

// OrgUnitTree is the resolver for the orgUnitTree field.
func (r *queryResolver) OrgUnitTree(ctx context.Context, gatewayID string) ([]*OrgUnit, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	tree, err := r.Store.GetOrgUnitTree(ctx, gid)
	if err != nil {
		return nil, err
	}
	// Flatten the tree for simple response (children are resolved separately)
	var result []*OrgUnit
	for i := range tree {
		result = append(result, orgUnitToGQL(&tree[i].OrgUnit))
	}
	return result, nil
}

// OrgUnitsByPath is the resolver for the orgUnitsByPath field.
func (r *queryResolver) OrgUnitsByPath(ctx context.Context, gatewayID string, pathPrefix string) ([]*OrgUnit, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	units, err := r.Store.GetOrgUnitsByPath(ctx, gid, pathPrefix)
	if err != nil {
		return nil, err
	}
	return orgUnitsToGQL(units), nil
}

// Principal is the resolver for the principal field.
func (r *queryResolver) Principal(ctx context.Context, id string) (*Principal, error) {
	pid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid principal ID: %w", err)
	}
	principal, err := r.Store.GetPrincipal(ctx, pid)
	if err != nil {
		return nil, err
	}
	return principalToGQL(principal), nil
}

// PrincipalByUser is the resolver for the principalByUser field.
func (r *queryResolver) PrincipalByUser(ctx context.Context, gatewayID string, userID string) (*Principal, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	uid, err := parseUUID(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}
	principal, err := r.Store.GetPrincipalByUserID(ctx, gid, uid)
	if err != nil {
		return nil, err
	}
	return principalToGQL(principal), nil
}

// Principals is the resolver for the principals field.
func (r *queryResolver) Principals(ctx context.Context, gatewayID string, filter *PrincipalFilter) ([]*Principal, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	principals, err := r.Store.ListPrincipals(ctx, gid, principalFilterToStore(filter))
	if err != nil {
		return nil, err
	}
	return principalsToGQL(principals), nil
}

// Budget is the resolver for the budget field.
func (r *queryResolver) Budget(ctx context.Context, id string) (*Budget, error) {
	bid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid budget ID: %w", err)
	}
	budget, err := r.Store.GetBudget(ctx, bid)
	if err != nil {
		return nil, err
	}
	return budgetToGQL(budget), nil
}

// Budgets is the resolver for the budgets field.
func (r *queryResolver) Budgets(ctx context.Context, gatewayID string) ([]*Budget, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	budgets, err := r.Store.ListBudgets(ctx, gid)
	if err != nil {
		return nil, err
	}
	return budgetsToGQL(budgets), nil
}

// APIKey is the resolver for the apiKey field.
func (r *queryResolver) APIKey(ctx context.Context, id string) (*APIKey, error) {
	kid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid API key ID: %w", err)
	}
	key, err := r.Store.GetAPIKeyV2(ctx, kid)
	if err != nil {
		return nil, err
	}
	return apiKeyToGQL(key), nil
}

// APIKeys is the resolver for the apiKeys field.
func (r *queryResolver) APIKeys(ctx context.Context, gatewayID string, filter *APIKeyFilter) ([]*APIKey, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	keys, err := r.Store.ListAPIKeysV2(ctx, gid, apiKeyFilterToStore(filter))
	if err != nil {
		return nil, err
	}
	return apiKeysToGQL(keys), nil
}

// ==============================================================================
// Mutation Resolvers
// ==============================================================================

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*User, error) {
	user, err := r.Store.CreateUserV2(ctx, createUserInputToParams(input))
	if err != nil {
		return nil, err
	}
	return userToGQL(user), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*User, error) {
	uid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}
	user, err := r.Store.UpdateUserV2(ctx, uid, updateUserInputToUpdate(input))
	if err != nil {
		return nil, err
	}
	return userToGQL(user), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	uid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}
	err = r.Store.DeleteUserV2(ctx, uid)
	return err == nil, err
}

// CreateGateway is the resolver for the createGateway field.
func (r *mutationResolver) CreateGateway(ctx context.Context, input CreateGatewayInput) (*Gateway, error) {
	// TODO: Get owner from authenticated user context
	return nil, fmt.Errorf("not implemented: authentication required to create gateway")
}

// UpdateGateway is the resolver for the updateGateway field.
func (r *mutationResolver) UpdateGateway(ctx context.Context, id string, input UpdateGatewayInput) (*Gateway, error) {
	gid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	update := userstore.GatewayUpdate{
		Alias:           input.Alias,
		ProviderEnabled: input.ProviderEnabled,
		ConsumerEnabled: input.ConsumerEnabled,
	}
	if input.Metadata != nil {
		meta := userstore.JSONMap(input.Metadata)
		update.Metadata = &meta
	}
	gw, err := r.Store.UpdateGateway(ctx, gid, update)
	if err != nil {
		return nil, err
	}
	return gatewayToGQL(gw), nil
}

// DeleteGateway is the resolver for the deleteGateway field.
func (r *mutationResolver) DeleteGateway(ctx context.Context, id string) (bool, error) {
	gid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid gateway ID: %w", err)
	}
	err = r.Store.DeleteGateway(ctx, gid)
	return err == nil, err
}

// AddGatewayMember is the resolver for the addGatewayMember field.
func (r *mutationResolver) AddGatewayMember(ctx context.Context, input AddGatewayMemberInput) (*GatewayMembership, error) {
	gid, err := parseUUID(input.GatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	uid, err := parseUUID(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}
	membership, err := r.Store.AddGatewayMember(ctx, gid, uid, userstore.GatewayMemberRole(input.Role))
	if err != nil {
		return nil, err
	}
	return gatewayMembershipToGQL(membership), nil
}

// UpdateGatewayMember is the resolver for the updateGatewayMember field.
func (r *mutationResolver) UpdateGatewayMember(ctx context.Context, membershipID string, role GatewayMemberRole) (bool, error) {
	mid, err := parseUUID(membershipID)
	if err != nil {
		return false, fmt.Errorf("invalid membership ID: %w", err)
	}
	err = r.Store.UpdateGatewayMember(ctx, mid, userstore.GatewayMemberRole(role))
	return err == nil, err
}

// RemoveGatewayMember is the resolver for the removeGatewayMember field.
func (r *mutationResolver) RemoveGatewayMember(ctx context.Context, membershipID string) (bool, error) {
	mid, err := parseUUID(membershipID)
	if err != nil {
		return false, fmt.Errorf("invalid membership ID: %w", err)
	}
	err = r.Store.RemoveGatewayMember(ctx, mid)
	return err == nil, err
}

// CreateOrgUnit is the resolver for the createOrgUnit field.
func (r *mutationResolver) CreateOrgUnit(ctx context.Context, input CreateOrgUnitInput) (*OrgUnit, error) {
	unit, err := r.Store.CreateOrgUnit(ctx, createOrgUnitInputToParams(input))
	if err != nil {
		return nil, err
	}
	return orgUnitToGQL(unit), nil
}

// UpdateOrgUnit is the resolver for the updateOrgUnit field.
func (r *mutationResolver) UpdateOrgUnit(ctx context.Context, id string, input UpdateOrgUnitInput) (*OrgUnit, error) {
	oid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid org unit ID: %w", err)
	}
	update := userstore.OrgUnitUpdate{
		Name: input.Name,
		Slug: input.Slug,
	}
	if input.AllowedModels != nil {
		update.AllowedModels = &input.AllowedModels
	}
	if input.UnitType != nil {
		ut := userstore.OrgUnitType(*input.UnitType)
		update.UnitType = &ut
	}
	if input.BudgetID != nil {
		update.BudgetID = ptrUUID(input.BudgetID)
	}
	if input.Metadata != nil {
		meta := userstore.JSONMap(input.Metadata)
		update.Metadata = &meta
	}
	unit, err := r.Store.UpdateOrgUnit(ctx, oid, update)
	if err != nil {
		return nil, err
	}
	return orgUnitToGQL(unit), nil
}

// MoveOrgUnit is the resolver for the moveOrgUnit field.
func (r *mutationResolver) MoveOrgUnit(ctx context.Context, id string, newParentID *string) (*OrgUnit, error) {
	oid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid org unit ID: %w", err)
	}
	unit, err := r.Store.MoveOrgUnit(ctx, oid, ptrUUID(newParentID))
	if err != nil {
		return nil, err
	}
	return orgUnitToGQL(unit), nil
}

// MergeOrgUnits is the resolver for the mergeOrgUnits field.
func (r *mutationResolver) MergeOrgUnits(ctx context.Context, sourceID string, targetID string) (bool, error) {
	sid, err := parseUUID(sourceID)
	if err != nil {
		return false, fmt.Errorf("invalid source ID: %w", err)
	}
	tid, err := parseUUID(targetID)
	if err != nil {
		return false, fmt.Errorf("invalid target ID: %w", err)
	}
	err = r.Store.MergeOrgUnits(ctx, sid, tid)
	return err == nil, err
}

// DeleteOrgUnit is the resolver for the deleteOrgUnit field.
func (r *mutationResolver) DeleteOrgUnit(ctx context.Context, id string, force *bool) (bool, error) {
	oid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid org unit ID: %w", err)
	}
	forceDelete := false
	if force != nil {
		forceDelete = *force
	}
	err = r.Store.DeleteOrgUnit(ctx, oid, forceDelete)
	return err == nil, err
}

// CreatePrincipal is the resolver for the createPrincipal field.
func (r *mutationResolver) CreatePrincipal(ctx context.Context, input CreatePrincipalInput) (*Principal, error) {
	principal, err := r.Store.CreatePrincipal(ctx, createPrincipalInputToParams(input))
	if err != nil {
		return nil, err
	}
	return principalToGQL(principal), nil
}

// UpdatePrincipal is the resolver for the updatePrincipal field.
func (r *mutationResolver) UpdatePrincipal(ctx context.Context, id string, input UpdatePrincipalInput) (*Principal, error) {
	pid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid principal ID: %w", err)
	}
	update := userstore.PrincipalUpdate{
		DisplayName: input.DisplayName,
	}
	if input.AllowedModels != nil {
		update.AllowedModels = &input.AllowedModels
	}
	if input.BudgetID != nil {
		update.BudgetID = ptrUUID(input.BudgetID)
	}
	if input.Metadata != nil {
		meta := userstore.JSONMap(input.Metadata)
		update.Metadata = &meta
	}
	principal, err := r.Store.UpdatePrincipal(ctx, pid, update)
	if err != nil {
		return nil, err
	}
	return principalToGQL(principal), nil
}

// DeletePrincipal is the resolver for the deletePrincipal field.
func (r *mutationResolver) DeletePrincipal(ctx context.Context, id string) (bool, error) {
	pid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid principal ID: %w", err)
	}
	err = r.Store.DeletePrincipal(ctx, pid)
	return err == nil, err
}

// AddOrgMembership is the resolver for the addOrgMembership field.
func (r *mutationResolver) AddOrgMembership(ctx context.Context, input CreateOrgMembershipInput) (*OrgMembership, error) {
	membership, err := r.Store.AddOrgMembership(ctx, createOrgMembershipInputToParams(input))
	if err != nil {
		return nil, err
	}
	return orgMembershipToGQL(membership), nil
}

// UpdateOrgMembership is the resolver for the updateOrgMembership field.
func (r *mutationResolver) UpdateOrgMembership(ctx context.Context, id string, input UpdateOrgMembershipInput) (bool, error) {
	mid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid membership ID: %w", err)
	}
	update := userstore.OrgMembershipUpdate{
		IsPrimary: input.IsPrimary,
	}
	if input.Role != nil {
		role := userstore.OrgMemberRole(*input.Role)
		update.Role = &role
	}
	if input.BudgetID != nil {
		update.BudgetID = ptrUUID(input.BudgetID)
	}
	err = r.Store.UpdateOrgMembership(ctx, mid, update)
	return err == nil, err
}

// RemoveOrgMembership is the resolver for the removeOrgMembership field.
func (r *mutationResolver) RemoveOrgMembership(ctx context.Context, id string) (bool, error) {
	mid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid membership ID: %w", err)
	}
	err = r.Store.RemoveOrgMembership(ctx, mid)
	return err == nil, err
}

// SetPrimaryMembership is the resolver for the setPrimaryMembership field.
func (r *mutationResolver) SetPrimaryMembership(ctx context.Context, principalID string, membershipID string) (bool, error) {
	pid, err := parseUUID(principalID)
	if err != nil {
		return false, fmt.Errorf("invalid principal ID: %w", err)
	}
	mid, err := parseUUID(membershipID)
	if err != nil {
		return false, fmt.Errorf("invalid membership ID: %w", err)
	}
	err = r.Store.SetPrimaryMembership(ctx, pid, mid)
	return err == nil, err
}

// CreateBudget is the resolver for the createBudget field.
func (r *mutationResolver) CreateBudget(ctx context.Context, gatewayID string, input CreateBudgetInput) (*Budget, error) {
	gid, err := parseUUID(gatewayID)
	if err != nil {
		return nil, fmt.Errorf("invalid gateway ID: %w", err)
	}
	budget, err := r.Store.CreateBudget(ctx, gid, createBudgetInputToParams(input))
	if err != nil {
		return nil, err
	}
	return budgetToGQL(budget), nil
}

// UpdateBudget is the resolver for the updateBudget field.
func (r *mutationResolver) UpdateBudget(ctx context.Context, id string, input UpdateBudgetInput) (*Budget, error) {
	bid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid budget ID: %w", err)
	}
	var tpmLimit, rpmLimit *int64
	if input.TpmLimit != nil {
		v := int64(*input.TpmLimit)
		tpmLimit = &v
	}
	if input.RpmLimit != nil {
		v := int64(*input.RpmLimit)
		rpmLimit = &v
	}
	var duration *userstore.BudgetDuration
	if input.BudgetDuration != nil {
		d := userstore.BudgetDuration(*input.BudgetDuration)
		duration = &d
	}
	update := userstore.BudgetUpdate{
		Name:           input.Name,
		MaxBudget:      input.MaxBudget,
		BudgetDuration: duration,
		TPMLimit:       tpmLimit,
		RPMLimit:       rpmLimit,
		SoftLimit:      input.SoftLimit,
	}
	if input.Metadata != nil {
		meta := userstore.JSONMap(input.Metadata)
		update.Metadata = &meta
	}
	budget, err := r.Store.UpdateBudget(ctx, bid, update)
	if err != nil {
		return nil, err
	}
	return budgetToGQL(budget), nil
}

// DeleteBudget is the resolver for the deleteBudget field.
func (r *mutationResolver) DeleteBudget(ctx context.Context, id string) (bool, error) {
	bid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid budget ID: %w", err)
	}
	err = r.Store.DeleteBudget(ctx, bid)
	return err == nil, err
}

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, input CreateAPIKeyInput) (*APIKeyCreationResult, error) {
	key, rawKey, err := r.Store.CreateAPIKeyV2(ctx, createAPIKeyInputToParams(input))
	if err != nil {
		return nil, err
	}
	return &APIKeyCreationResult{
		APIKey: apiKeyToGQL(key),
		RawKey: rawKey,
	}, nil
}

// UpdateAPIKey is the resolver for the updateAPIKey field.
func (r *mutationResolver) UpdateAPIKey(ctx context.Context, id string, input UpdateAPIKeyInput) (*APIKey, error) {
	kid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid API key ID: %w", err)
	}
	update := userstore.APIKeyV2Update{
		KeyName:   input.KeyName,
		ExpiresAt: input.ExpiresAt,
		Blocked:   input.Blocked,
	}
	if input.AllowedModels != nil {
		update.AllowedModels = &input.AllowedModels
	}
	if input.AllowedIps != nil {
		update.AllowedIPs = &input.AllowedIps
	}
	if input.BudgetID != nil {
		update.BudgetID = ptrUUID(input.BudgetID)
	}
	key, err := r.Store.UpdateAPIKeyV2(ctx, kid, update)
	if err != nil {
		return nil, err
	}
	return apiKeyToGQL(key), nil
}

// RotateAPIKey is the resolver for the rotateAPIKey field.
func (r *mutationResolver) RotateAPIKey(ctx context.Context, id string, gracePeriodMinutes *int) (*APIKeyCreationResult, error) {
	kid, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid API key ID: %w", err)
	}
	gracePeriod := time.Duration(0)
	if gracePeriodMinutes != nil {
		gracePeriod = time.Duration(*gracePeriodMinutes) * time.Minute
	}
	key, rawKey, err := r.Store.RotateAPIKeyV2(ctx, kid, gracePeriod)
	if err != nil {
		return nil, err
	}
	return &APIKeyCreationResult{
		APIKey: apiKeyToGQL(key),
		RawKey: rawKey,
	}, nil
}

// RevokeAPIKey is the resolver for the revokeAPIKey field.
func (r *mutationResolver) RevokeAPIKey(ctx context.Context, id string) (bool, error) {
	kid, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid API key ID: %w", err)
	}
	err = r.Store.RevokeAPIKeyV2(ctx, kid)
	return err == nil, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Ensure unused imports don't cause errors
var _ = uuid.Nil
